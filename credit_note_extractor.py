# -*- coding: utf-8 -*-
"""Credit Note Extractor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JXFfljKL1YAy1K_Elu2-OgfeRGNZmo6K
"""

import streamlit as st
import pandas as pd
import re
from io import BytesIO
from datetime import datetime
import base64

# Page configuration
st.set_page_config(
    page_title="Credit Memo Extractor",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

class CreditMemoExtractor:
    def __init__(self):
        self.extracted_data = []

    def process_file(self, uploaded_file):
        """Process uploaded file and extract data"""
        try:
            file_ext = uploaded_file.name.split('.')[-1].lower()

            # Read file based on extension
            if file_ext in ['xls', 'xlsx']:
                xls = pd.ExcelFile(uploaded_file)
                sheets = {sheet: xls.parse(sheet_name=sheet, header=None) for sheet in xls.sheet_names}
            elif file_ext == 'csv':
                df_csv = pd.read_csv(uploaded_file, header=None)
                sheets = {'Sheet1': df_csv}
            else:
                st.error("Unsupported file format. Please upload Excel (.xlsx, .xls) or CSV files.")
                return None

            st.success(f"‚úÖ File loaded successfully! Found {len(sheets)} sheet(s)")

            # Process all sheets
            self.extracted_data = []
            progress_bar = st.progress(0)

            for i, (sheet_name, df) in enumerate(sheets.items()):
                st.write(f"üîÑ Processing sheet: **{sheet_name}**")
                memo_info = self.extract_credit_memo_info(df, sheet_name)
                memo_info['sheet_name'] = sheet_name
                self.extracted_data.append(memo_info)

                # Update progress
                progress_bar.progress((i + 1) / len(sheets))

            return self.create_final_dataframe()

        except Exception as e:
            st.error(f"Error processing file: {str(e)}")
            return None

    def extract_credit_memo_info(self, df, sheet_name):
        """Extract credit memo information"""
        with st.expander(f"üìã Extraction Details for {sheet_name}", expanded=False):
            # Extract credit memo number
            credit_memo_no = self.find_credit_memo_number(df)

            # Extract invoice number
            invoice_no = self.find_invoice_number(df)

            # Extract line items
            items = self.extract_line_items(df)

            # Display results
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Credit Memo No", credit_memo_no or "Not found")
            with col2:
                st.metric("Invoice No", invoice_no or "Not found")
            with col3:
                st.metric("Items Found", len(items))

        return {
            'credit_memo_no': credit_memo_no,
            'invoice_no': invoice_no,
            'items': items
        }

    def find_credit_memo_number(self, df):
        """Find credit memo number with merged cell handling"""
        st.write("üîç Searching for Credit Memo Number...")

        # Strategy 1: Handle merged cell structure (Label: B-C, Value: G-K)
        for row_idx in range(len(df)):
            label_found = False

            # Check columns B and C for the label
            for label_col in [1, 2]:  # B=1, C=2
                if label_col < len(df.columns):
                    try:
                        cell_value = df.iat[row_idx, label_col]
                        if pd.notna(cell_value) and 'Credit Memo No' in str(cell_value):
                            label_found = True
                            st.write(f"‚úÖ Found 'Credit Memo No.' label at row {row_idx+1}, column {chr(65+label_col)}")
                            break
                    except (IndexError, KeyError):
                        continue

            # If label found, look for value in columns G-K
            if label_found:
                st.write(f"üîç Searching for value in merged cells G-K (row {row_idx+1})...")
                for value_col in range(6, min(11, len(df.columns))):  # G=6 to K=10
                    try:
                        value_cell = df.iat[row_idx, value_col]
                        if pd.notna(value_cell):
                            cell_str = str(value_cell).strip()
                            if cell_str.isdigit() and len(cell_str) >= 5:
                                st.success(f"‚úÖ Found Credit Memo Number: **{cell_str}** at column {chr(65+value_col)}")
                                return cell_str
                            elif cell_str and cell_str.lower() not in ['nan', 'none', 'null']:
                                digits = re.findall(r'\d+', cell_str)
                                if digits:
                                    candidate = max(digits, key=len)
                                    if len(candidate) >= 5:
                                        st.success(f"‚úÖ Extracted Credit Memo Number: **{candidate}** from '{cell_str}'")
                                        return candidate
                    except (IndexError, KeyError):
                        continue

        # Strategy 2: Pattern matching fallback
        df_str = df.to_string()
        patterns = [
            r'Credit Memo No\.,+\s*(\d+)',
            r'Credit Memo No\.\s*,+\s*(\d+)',
            r'Credit Memo No\.,+(\d+)',
        ]

        for pattern in patterns:
            match = re.search(pattern, df_str)
            if match:
                st.success(f"‚úÖ Found Credit Memo No using pattern: **{match.group(1)}**")
                return match.group(1)

        st.warning("‚ö†Ô∏è Credit Memo Number not found")
        return None

    def find_invoice_number(self, df):
        """Find invoice number using pattern matching"""
        df_str = df.to_string()

        patterns = [
            r'Invoice No\.\s*(\d+):?',
            r'Inv\. No\.\s*(\d+)',
            r'Invoice No\s+(\d+)',
        ]

        for pattern in patterns:
            match = re.search(pattern, df_str)
            if match:
                st.success(f"‚úÖ Found Invoice No: **{match.group(1)}**")
                return match.group(1)

        st.warning("‚ö†Ô∏è Invoice Number not found")
        return None

    def extract_line_items(self, df):
        """Extract line items from the credit memo"""
        items = []
        header_found = False
        item_start_row = None

        # Find header row
        for idx, row in df.iterrows():
            row_str = ' '.join([str(cell) for cell in row if pd.notna(cell)])
            if ('No.' in row_str and 'Description' in row_str and
                ('Qty' in row_str or 'Quantity' in row_str) and 'UOM' in row_str):
                header_found = True
                item_start_row = idx
                st.write(f"‚úÖ Found item header at row {idx+1}")
                break

        if not header_found:
            st.warning("‚ö†Ô∏è Item header not found")
            return items

        # Extract items
        for idx in range(item_start_row + 1, len(df)):
            row = df.iloc[idx]
            row_values = [str(cell).strip() for cell in row if pd.notna(cell) and str(cell).strip() != '']

            if len(row_values) < 2:
                continue

            # Stop at summary sections
            row_str = ' '.join(row_values).lower()
            if any(keyword in row_str for keyword in ['subtotal', 'vat amount', 'total kes', 'vat identifier']):
                break

            # Parse item
            item_info = self.parse_item_row(row_values)
            if item_info and item_info.get('description') and item_info.get('description').upper() != 'QUALITY':
                items.append(item_info)

        st.success(f"‚úÖ Extracted {len(items)} items")
        return items

    def parse_item_row(self, row_values):
        """Parse individual item row"""
        if len(row_values) < 2:
            return None

        item = {
            'no': '',
            'description': '',
            'qty': '',
            'uom': '',
            'unit_price_excl_vat': '',
            'vat_percent': '',
            'line_amount_excl_vat': ''
        }

        try:
            item['no'] = row_values[0] if len(row_values) > 0 else ''
            item['description'] = row_values[1] if len(row_values) > 1 else ''

            # Find quantity
            qty_idx = 2
            while qty_idx < len(row_values):
                val = row_values[qty_idx]
                if val.replace('.', '').replace(',', '').isdigit():
                    item['qty'] = val
                    break
                qty_idx += 1

            # Fill remaining fields
            if qty_idx < len(row_values) - 1:
                remaining = row_values[qty_idx + 1:]
                item['uom'] = remaining[0] if len(remaining) > 0 else ''
                item['unit_price_excl_vat'] = remaining[1] if len(remaining) > 1 else ''
                item['vat_percent'] = remaining[2] if len(remaining) > 2 else ''
                item['line_amount_excl_vat'] = remaining[3] if len(remaining) > 3 else ''

        except (IndexError, ValueError):
            pass

        return item

    def create_final_dataframe(self):
        """Create final cleaned dataframe"""
        all_items = []

        for memo in self.extracted_data:
            sheet = memo.get('sheet_name', 'Unknown')
            credit_memo_no = memo.get('credit_memo_no', 'N/A')
            invoice_no = memo.get('invoice_no', 'N/A')

            for item in memo.get('items', []):
                row = {
                    'Sheet Name': sheet,
                    'Credit Memo No': credit_memo_no,
                    'Invoice No': invoice_no,
                    'Item No': item.get('no', ''),
                    'Description': item.get('description', ''),
                    'Quantity': item.get('qty', ''),
                    'UOM': item.get('uom', ''),
                    'Unit Price Excl VAT': item.get('unit_price_excl_vat', ''),
                    'VAT %': item.get('vat_percent', ''),
                    'Line Amount Excl VAT': item.get('line_amount_excl_vat', '')
                }
                all_items.append(row)

        df_final = pd.DataFrame(all_items)

        # Clean the data
        if not df_final.empty:
            df_final = df_final[df_final['Description'].notna()]
            df_final = df_final[df_final['Description'].str.strip() != '']
            df_final = df_final.reset_index(drop=True)

        return df_final


def create_download_link(df, filename):
    """Create download link for Excel file"""
    output = BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        df.to_excel(writer, sheet_name='Extracted_Data', index=False)

    output.seek(0)
    b64 = base64.b64encode(output.read()).decode()

    return f'<a href="data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,{b64}" download="{filename}">üì• Download Excel File</a>'


def main():
    """Main Streamlit app"""
    # Header
    st.title("üìä Credit Memo Data Extractor")
    st.markdown("---")

    # Sidebar
    st.sidebar.header("üìã How it works")
    st.sidebar.markdown("""
    1. **Upload** your Excel/CSV file
    2. **Extract** credit memo data automatically
    3. **Review** the results
    4. **Download** cleaned Excel file

    ### ‚úÖ What we extract:
    - Credit Memo Numbers
    - Invoice Numbers
    - Line items (Description, Qty, Prices, etc.)

    ### üìÅ Supported formats:
    - Excel (.xlsx, .xls)
    - CSV (.csv)
    """)

    # File upload
    st.header("üìÅ Upload Your Credit Memo File")
    uploaded_file = st.file_uploader(
        "Choose a file",
        type=['xlsx', 'xls', 'csv'],
        help="Upload Excel or CSV files containing credit memo data"
    )

    if uploaded_file is not None:
        # Show file info
        st.info(f"üìÑ File: **{uploaded_file.name}** ({uploaded_file.size:,} bytes)")

        # Initialize extractor
        extractor = CreditMemoExtractor()

        # Process file
        with st.spinner("Processing file..."):
            df_result = extractor.process_file(uploaded_file)

        if df_result is not None and not df_result.empty:
            st.success("üéâ Extraction completed successfully!")

            # Display summary
            st.header("üìä Extraction Summary")
            col1, col2, col3, col4 = st.columns(4)

            with col1:
                st.metric("üìã Total Records", len(df_result))
            with col2:
                st.metric("üìÑ Credit Memos", df_result['Credit Memo No'].nunique())
            with col3:
                st.metric("üßæ Invoices", df_result['Invoice No'].nunique())
            with col4:
                st.metric("üìä Sheets Processed", df_result['Sheet Name'].nunique())

            # Display data preview
            st.header("üëÄ Data Preview")
            st.dataframe(df_result.head(10), use_container_width=True)

            # Credit memo breakdown
            st.header("üìà Credit Memo Breakdown")
            memo_breakdown = df_result.groupby('Credit Memo No').size().reset_index(name='Item Count')
            memo_breakdown = memo_breakdown[memo_breakdown['Credit Memo No'] != 'N/A']

            if not memo_breakdown.empty:
                st.dataframe(memo_breakdown, use_container_width=True)

                # Chart
                st.bar_chart(memo_breakdown.set_index('Credit Memo No'))
            else:
                st.warning("No valid credit memo numbers found.")

            # Download section
            st.header("üì• Download Results")

            # Create filename
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            base_name = uploaded_file.name.split('.')[0]
            filename = f"{base_name}_extracted_{timestamp}.xlsx"

            # Download button
            download_link = create_download_link(df_result, filename)
            st.markdown(download_link, unsafe_allow_html=True)

            st.success(f"‚úÖ Ready to download: **{filename}**")
            st.info("üí° The Excel file contains all extracted credit memo data in a clean, structured format.")

        elif df_result is not None and df_result.empty:
            st.warning("‚ö†Ô∏è No valid data found in the uploaded file. Please check the file format.")
        else:
            st.error("‚ùå Failed to process the file. Please try again or check the file format.")

    else:
        st.info("üëÜ Please upload a file to get started!")

        # Show sample format
        st.header("üìã Sample File Format")
        st.markdown("""
        Your file should contain credit memo data with:
        - **Credit Memo No.** in merged cells B-C with value in G-K
        - **Invoice No.** followed by a colon
        - **Item details** in tabular format with headers: No., Description, Qty, UOM, Unit Price, VAT %, Line Amount
        """)


if __name__ == "__main__":
    main()